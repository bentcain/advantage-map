<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Parcel Requests Dashboard</title>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px; }
    th, td { border: 1px solid #ccc; padding: 6px; vertical-align: top; }
    input, select, textarea { width: 100%; font-size: 14px; }
    textarea { resize: vertical; }
  </style>
</head>
<body>
  <h2>Parcel Requests Dashboard</h2>
  <input type="text" id="searchInput" placeholder="Search..." />
  <table id="requestsTable">
    <thead>
      <tr id="filterRow"></tr>
      <tr id="headerRow"></tr>
    </thead>
    <tbody></tbody>
  </table>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.7.0/firebase-app.js";
    import { getDatabase, ref, child, get, update } from "https://www.gstatic.com/firebasejs/11.7.0/firebase-database.js";
    import { firebaseConfig } from './firebase-config.js';

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const currentUser = localStorage.getItem("username") || "Ben";

    let config = {}, statusColors = {}, statusOrder = {}, parcels = {}, fbData = {};

    async function loadConfig() {
      const res = await fetch("project_config.json");
      config = await res.json();
      config.statuses.forEach(s => {
        statusColors[s.name] = s.color;
        statusOrder[s.name.toLowerCase()] = s.order;
      });
    }

    async function loadGeojson() {
      const file = await fetch("geojson_filename.txt").then(r => r.text());
      const data = await fetch(file.trim()).then(r => r.json());
      data.features.forEach(f => {
        const uid = f.properties.uid;
        if (uid) parcels[uid] = f.properties;
      });
    }

    async function loadFirebase() {
      const snapshot = await get(ref(db));
      fbData = snapshot.val() || {};
    }

    function buildTable() {
      const uids = Object.keys(parcels);
      const dynamicCols = config.columns.filter(c => c !== "uid" && c !== "Status");
      const columns = ["uid", ...dynamicCols.slice(0, 2), "Status", "Request", "Request State", "Assigned To", "Created By", "Created", "Reply", "Actions"];

      const headerRow = document.getElementById("headerRow");
      const filterRow = document.getElementById("filterRow");
      const tbody = document.querySelector("#requestsTable tbody");
      headerRow.innerHTML = "";
      filterRow.innerHTML = "";
      tbody.innerHTML = "";

      columns.forEach(col => {
        headerRow.innerHTML += `<th>${col}</th>`;
        const fth = document.createElement("th");
        if (!["Reply", "Actions"].includes(col)) {
          const sel = document.createElement("select");
          sel.innerHTML = `<option value="">All</option>`;
          sel.dataset.col = col;
          sel.className = "filter";
          fth.appendChild(sel);
        }
        filterRow.appendChild(fth);
      });

      const rowData = [];

      uids.forEach(uid => {
        const parcel = parcels[uid] || {};
        const fb = fbData[uid] || {};
        const status = fb.status || parcel.Status || "New";
        const requests = fbData.requests?.[uid] || {};

        Object.entries(requests).forEach(([reqId, req]) => {
          const comments = Array.isArray(req.comments) ? req.comments : Object.values(req.comments || {});
          const tr = document.createElement("tr");
          tr.style.backgroundColor = statusColors[status] || "";

          const searchable = `${uid} ${dynamicCols.map(k => parcel[k] || "").join(" ")} ${status} ${req.text} ${req.assignedTo} ${req.createdBy}`.toLowerCase();
          tr.dataset.searchable = searchable;

          columns.forEach(col => {
            const td = document.createElement("td");
            if (col === "uid") td.textContent = uid;
            else if (dynamicCols.includes(col)) td.textContent = parcel[col] || "";
            else if (col === "Status") td.textContent = status;
            else if (col === "Request") td.textContent = req.text || "";
            else if (col === "Request State") td.textContent = req.status || "open";
            else if (col === "Assigned To") td.textContent = req.assignedTo || "";
            else if (col === "Created By") td.textContent = req.createdBy || "";
            else if (col === "Created") td.textContent = new Date(req.createdAt).toLocaleString();
            else if (col === "Reply") {
              const ta = document.createElement("textarea");
              const replyBtn = document.createElement("button");
              replyBtn.textContent = "Reply";
              replyBtn.onclick = () => {
                const note = ta.value.trim();
                if (!note) return;
                const comment = {
                  text: note,
                  user: currentUser,
                  timestamp: new Date().toISOString()
                };
                const path = `requests/${uid}/${reqId}/comments`;
                get(child(ref(db), path)).then(snapshot => {
                  const comments = snapshot.val() || [];
                  comments.push(comment);
                  update(ref(db, `requests/${uid}/${reqId}`), { comments }).then(() => location.reload());
                });
              };
              td.appendChild(ta);
              td.appendChild(replyBtn);

              if (req.status !== "closed") {
                const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close Request";
                closeBtn.onclick = () => {
                  update(ref(db, `requests/${uid}/${reqId}`), { status: "closed" }).then(() => location.reload());
                };
                td.appendChild(closeBtn);
              }
            } else if (col === "Actions") {
              td.innerHTML = `<a href="notes.html?uid=${uid}" target="_blank">View Notes</a>`;
            }
            tr.appendChild(td);
          });

          const order = statusOrder[status.toLowerCase()] || 99;
          rowData.push({ tr, order });
        });
      });

      rowData
        .sort((a, b) => a.order - b.order)
        .forEach(r => tbody.appendChild(r.tr));

      document.querySelectorAll("select.filter").forEach(sel => {
        const col = sel.dataset.col;
        const idx = columns.indexOf(col);
        const values = new Set();
        rowData.forEach(r => {
          const val = r.tr.cells[idx]?.textContent;
          if (val) values.add(val);
        });
        [...values].sort().forEach(v => {
          const opt = document.createElement("option");
          opt.value = v;
          opt.textContent = v;
          sel.appendChild(opt);
        });
        sel.addEventListener("change", applyFilters);
      });
    }

    function applyFilters() {
      const terms = {};
      document.querySelectorAll("select.filter").forEach(sel => {
        if (sel.value) terms[sel.dataset.col] = sel.value;
      });
      document.querySelectorAll("tbody tr").forEach(tr => {
        const visible = Object.entries(terms).every(([col, val]) => {
          const idx = [...tr.cells].findIndex((_, i) => document.getElementById("headerRow").children[i].textContent === col);
          return tr.cells[idx]?.textContent.includes(val);
        });
        tr.style.display = visible ? "" : "none";
      });
    }

    document.getElementById("searchInput").addEventListener("input", () => {
      const term = document.getElementById("searchInput").value.toLowerCase();
      document.querySelectorAll("tbody tr").forEach(tr => {
        tr.style.display = tr.dataset.searchable.includes(term) ? "" : "none";
      });
    });

    await loadConfig();
    await loadGeojson();
    await loadFirebase();
    buildTable();
  </script>
</body>
</html>
