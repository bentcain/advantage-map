<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Notes Dashboard</title>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }
    input[type="text"] {
      margin-bottom: 10px;
      padding: 4px;
      width: 300px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
    }
    thead th {
      position: sticky;
      top: 0;
      background: white;
      z-index: 1;
    }
    th, td {
      padding: 6px;
      border: 1px solid #ccc;
    }
    select.filter {
      width: 100%;
      margin-bottom: 4px;
    }
    textarea {
      width: 95%;
      resize: vertical;
    }
  </style>
</head>
<body>
  <h2>Parcel Notes Dashboard</h2>
  <input type="text" id="searchInput" placeholder="Search notes..." />
  <table id="notesTable">
    <thead>
      <tr id="filterRow"></tr>
      <tr id="headerRow"></tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyD7JkobzpJcrOHU_fNwXuEQqdYL1iAiiRQ",
      authDomain: "parcel-notes-system.firebaseapp.com",
      projectId: "parcel-notes-system",
      storageBucket: "parcel-notes-system.appspot.com",
      messagingSenderId: "538142262863",
      appId: "1:538142262863:web:89dfd4cf60bb2dc4694c3a",
      databaseURL: "https://parcel-notes-system-default-rtdb.firebaseio.com"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let config = {};
    let statusColors = {};
    let parcels = {};
    let allRows = [];

    async function loadConfig() {
      const res = await fetch("project_config.json");
      config = await res.json();
      config.statuses.forEach(s => {
        statusColors[s.name] = s.color;
      });
    }

    async function loadGeojson() {
      const geojsonFile = await fetch("geojson_filename.txt").then(r => r.text());
      const geojsonData = await fetch(geojsonFile.trim()).then(r => r.json());
      geojsonData.features.forEach(f => {
        const uid = f.properties.uid;
        if (uid) parcels[uid] = f.properties;
      });
    }

    async function loadNotes() {
      const snapshot = await db.ref().once("value");
      const all = snapshot.val() || {};
      const tbody = document.querySelector("#notesTable tbody");
      const headerRow = document.getElementById("headerRow");
      const filterRow = document.getElementById("filterRow");

      const displayColumns = ["uid", config.columns[0], config.columns[1], "Status", "New Note", "Save", "Note History"];
      displayColumns.forEach((col, i) => {
        const th = document.createElement("th");
        th.textContent = col;
        headerRow.appendChild(th);

        const fth = document.createElement("th");
        if (!["New Note", "Save"].includes(col)) {
          const select = document.createElement("select");
          select.className = "filter";
          select.dataset.index = i;
          select.innerHTML = `<option value="">All</option>`;
          fth.appendChild(select);
        }
        filterRow.appendChild(fth);
      });

      Object.entries(all).forEach(([uid, data]) => {
        const parcel = parcels[uid] || {};
        const status = data.status || "New";
        const notes = data.notes || [];
        const lastNote = notes.length > 0 ? notes[notes.length - 1].text : "";

        const tr = document.createElement("tr");
        tr.dataset.searchable = JSON.stringify({ ...parcel, ...data }).toLowerCase();
        if (statusColors[status]) tr.style.backgroundColor = statusColors[status];

        const rowData = {
          uid: uid,
          [config.columns[0]]: parcel[config.columns[0]] || "",
          [config.columns[1]]: parcel[config.columns[1]] || ""
        };

        displayColumns.forEach(col => {
          const td = document.createElement("td");

          if (col === "uid") td.textContent = uid;
          else if (col === config.columns[0] || col === config.columns[1]) td.textContent = rowData[col];
          else if (col === "Status") {
            const select = document.createElement("select");
            config.statuses.forEach(s => {
              const opt = document.createElement("option");
              opt.value = s.name;
              opt.textContent = s.name;
              if (s.name === status) opt.selected = true;
              select.appendChild(opt);
            });
            td.appendChild(select);
          }
          else if (col === "New Note") {
            const textarea = document.createElement("textarea");
            textarea.rows = 3;
            td.appendChild(textarea);
          }
          else if (col === "Save") {
            const btn = document.createElement("button");
            btn.textContent = "ðŸ’¾ Save";
            btn.onclick = () => {
              const newStatus = tr.querySelector("select").value;
              const note = tr.querySelector("textarea").value.trim();
              const updateObj = {};
              if (newStatus) updateObj.status = newStatus;

              if (note) {
                const existing = data.notes || [];
                existing.push({
                  text: note,
                  user: "Ben",
                  timestamp: new Date().toISOString()
                });
                updateObj.notes = existing;
              }

              db.ref(uid).update(updateObj).then(() => {
                alert("Saved.");
                location.reload();
              });
            };
            td.appendChild(btn);
          }
          else if (col === "Note History") {
            td.innerHTML = notes.map(n => `<div>${n.text}<br><small>${n.user || ""} â€“ ${n.timestamp || ""}</small></div>`).join("<hr>");
          }

          tr.appendChild(td);
        });

        allRows.push(tr);
        tbody.appendChild(tr);
      });

      // Populate filters
      displayColumns.forEach((col, i) => {
        const values = new Set();
        allRows.forEach(tr => {
          const td = tr.children[i];
          if (td) values.add(td.textContent.trim());
        });
        const select = filterRow.children[i]?.querySelector("select");
        if (select) {
          [...values].sort().forEach(val => {
            const opt = document.createElement("option");
            opt.value = val;
            opt.textContent = val;
            select.appendChild(opt);
          });
        }
      });
    }

    async function init() {
      await loadConfig();
      await loadGeojson();
      await loadNotes();
    }

    init();

    // Debounced search
    let searchTimeout = null;
    document.getElementById("searchInput").addEventListener("input", e => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        const val = e.target.value.toLowerCase();
        document.querySelectorAll("#notesTable tbody tr").forEach(tr => {
          tr.style.display = tr.dataset.searchable.includes(val) ? "" : "none";
        });
      }, 300);
    });

    // Filter logic
    document.getElementById("filterRow").addEventListener("change", () => {
      const filters = [...document.querySelectorAll("select.filter")].map(s => s.value);
      document.querySelectorAll("#notesTable tbody tr").forEach(tr => {
        const tds = tr.children;
        let visible = true;
        filters.forEach((val, i) => {
          if (val && !tds[i].textContent.includes(val)) visible = false;
        });
        tr.style.display = visible ? "" : "none";
      });
    });
  </script>
</body>
</html>
